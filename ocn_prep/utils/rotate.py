import numpy as np
import xarray as xr
import netCDF4 as nc
from netCDF4 import Dataset
from scipy.sparse import coo_matrix

def main():
    u = 'u'
    v = 'v'
    a = 'angle_dx'
    uf = 'MOM.res.nc'
    vf = 'MOM.res_1.nc'
    af = 'mx025.ocean_hgrid.nc'
    uw = 'mx025.u2h_weights.nc'
    vw = 'mx025.v2h_weights.nc'

    udata = read_variable_from_file(uf, u)
    vdata = read_variable_from_file(vf, v)
    adata = convert_angle_to_subgrid(read_variable_from_file(af, a), "center")

    print("==== Confirming Shapes ====")
    print(np.shape(udata))
    print(np.shape(vdata))
    print(np.shape(adata))
    print("===========================")

    # Remap U
    uremap = interpolate(np.array(udata[:]), uw)

    # Remap V
    vremap = interpolate(np.array(vdata[:]), vw)

    # Rotate U-V Vector
    urotate, vrotate = rotate_vector(uremap, vremap, adata, "src")
#    urotate = uremap
#    vrotate = vremap

    print("==== Confirming Shapes ====")
    print(np.shape(urotate))
    print(np.shape(vrotate))
    print("===========================")

    # Output to file
    with Dataset("vector.nc", "a", format="NETCDF4") as ds:
        ds.createDimension('time', np.shape(urotate)[0])
        ds.createDimension('depth', np.shape(urotate)[1])
        ds.createDimension('y', np.shape(urotate)[2])
        ds.createDimension('x', np.shape(urotate)[3])
        var_u = ds.createVariable('u', 'f4', ('time', 'depth', 'y', 'x'))
        var_u[:] = urotate
        var_v = ds.createVariable('v', 'f4', ('time', 'depth', 'y', 'x'))
        var_v[:] = vrotate


def interpolate(data_in, weights):
    N = 1.2676506e+30
    t = 0
    d = 0
    data_in = data_in[t,d,:,:]
    S_mat, dst_dims, nb = unpack_weights(weights)
    dims = (1,1, int(dst_dims[1]), int(dst_dims[0]))
    data = np.zeros((1, 1, nb))

    print(np.shape(data))
    print(np.shape(data_in))
    print(np.shape(S_mat))

    # Interpolate
    data_level = np.where(data_in.ravel()==N, 0, data_in.ravel())
    print(np.shape(data_level))
    data[t,d,:] = S_mat.dot(data_level)

    return data.reshape(dims)

def convert_angle_to_subgrid(var, gridtype):
    """Converts from supergrid to specified subgrid points"""
    if gridtype == "center": # Extract center points of grid
        cvar = var[1::2, 1::2]
    elif gridtype == "u": # Extract the East/West edges of grid
        cvar = var[1::2,0::2]
    elif gridtype == "v": # Extract the North/South edges of grid
        cvar = var[0::2,1::2]
    else:
        raise ValueError("Grid type not supported. Must be center, u, or v")

    return cvar

def rotate_vector(u, v, a, grid):
    """ Rotates vector from North-East alignment to grid alignment specified by the angle, a """
    print(np.max(a), np.min(a))
    cosa = np.cos(np.radians(a))
    sina = np.sin(np.radians(a))

    if grid=='dst':
        rotated_u = u*cosa + v*sina
        rotated_v = v*cosa - u*sina
    elif grid=='src':
        rotated_u = u*cosa - v*sina
        rotated_v = v*cosa + u*sina

    return rotated_u, rotated_v

def read_variable_from_file(fname, vname):
    """ Read a specified variable from a NetCDF file.

    Parameters:
        fname (str): Path to the NetCDF file from which the variable will be read.
        vname (str): The name of the variable to be read from the file.

    Returns:
        netCDF4.Variable: Variable object from the NetCDF file. This allows deferred loading of data.
    """
    ds = Dataset(fname, 'r')

    if vname not in ds.variables:
        raise KeyError(f"Variable '{vname}' not found in file '{fname}'.")
    else:
        return ds[vname]

def unpack_weights(wgt_file):
    """ Unpacks weight file generated by ESMF_RegridWeightGen """
    wgt_grid = Dataset(wgt_file, 'r')
    na = len(wgt_grid.dimensions['n_a'])
    nb = len(wgt_grid.dimensions['n_b'])
    col = np.array(wgt_grid.variables['col'][:])-1 # Convert to 0-base order
    row = np.array(wgt_grid.variables['row'][:])-1
    S = np.array(wgt_grid.variables['S'][:])
    S_mat = coo_matrix((S, (row, col)), shape=(nb, na))

    dst_dims = wgt_grid.variables['dst_grid_dims']

    return S_mat, dst_dims, nb

if __name__=="__main__":
    main()
