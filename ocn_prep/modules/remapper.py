from abc import ABC, abstractmethod
import numpy as np
import netCDF4 as nc
from netCDF4 import Dataset
from scipy.sparse import coo_matrix

###########################
### Base Remapper Class ###
###########################

class Remapper:
    def __new__(cls, *args, depth_name = None, convert_angle=False):
        """ Determine data type based on number of input dimensions and instantiate accordingly """
        if (len(args)<1 or len(args)>3):
            raise ValueError("Must provide either 1 (scalar) or 2 (vector, no grid angle) or 3 (vector and grid angle) netCDF4 variables")

        if not all(isinstance(var, nc.Variable) for var in args):
            raise ValueError("All positional arguments must be netCDF4 variables")

        dataset = args[0].group()

        def check_depth_dimension(dataset):
            if depth_name is not None:
                if depth_name not in dataset.dimensions:
                    raise ValueError(f"Specified depth dimension '{depth_name}' not found.")
                return len(dataset.dimensions[depth_name])

            depth_dims = {'depth', 'depths', 'z'}
            for dim_name, dim in dataset.dimensions.items():
                if dim_name.lower() in depth_dims:
                    return len(dim)

            return 0

        ndepths = check_depth_dimension(dataset)

        if len(args) == 1:
            if ndepths>1:
                instance = _Remapper3DScalar(args, ndepths)
            else:
                instance = _Remapper2DScalar(args)
        else:
            if ndepths>1:
                instance = _Remapper3DVector(args, ndepths, convert_angle)
            else:
                raise ValueError("Vector interpolation only implemented for 3D data")

        return instance

    @staticmethod
    def unpack_weights(wgt_file):
        """ Unpacks weight file generated by ESMF_RegridWeightGen """
        wgt_grid = Dataset(wgt_file, 'r')
        na = len(wgt_grid.dimensions['n_a'])
        nb = len(wgt_grid.dimensions['n_b'])
        col = np.array(wgt_grid.variables['col'][:])-1 # Convert to 0-base order
        row = np.array(wgt_grid.variables['row'][:])-1
        S = np.array(wgt_grid.variables['S'][:])
        S_mat = coo_matrix((S, (row, col)), shape=(nb, na))

        dst_dims = wgt_grid.variables['dst_grid_dims']
    
        return S_mat, dst_dims, nb


class _RemapperBase(ABC):
    @abstractmethod
    def remap_from_file(self, wgt_file) -> np.ndarray:
        pass

    @abstractmethod
    def write_to_file(self, out_file, var_name_out) -> None:
        pass

#######################
### 2D Scalar Class ###
#######################

class _Remapper2DScalar(_RemapperBase):
    """ Class for 2D scalar dataype (ssh) """
    def __init__(self, args):
        self.data = args[0]
        self.remapped = None

    def remap_from_file(self, wgt_file):
        S_mat, dst_dims, __ = Remapper.unpack_weights(wgt_file)

        dims = (1, dst_dims[1], dst_dims[0]) # Dims are flipped

        N = 1.2676506e+30 # NaN placeholder value

        t = 0
        data_src = np.array(self.data[t,:,:])
        data_level = np.where(data_src.ravel()==N, 0, data_src.ravel())
        data_interp = S_mat.dot(data_level)

        data_interp = data_interp.reshape(dims)

        self.remapped = data_interp

    def write_to_file(self, out_file, dz_name_out, time_name_out, *var_name_out):
        var_name_out = var_name_out[0] # Should only have one input for Scalar Classes
        if self.remapped is None:
            raise ValueError(f"No remapped data to write out.")

        __, ny, nx = np.shape(self.remapped)

        with Dataset(out_file, 'a', format='NETCDF4') as ds:
            if 'yh' not in ds.dimensions:
                ds.createDimension('yh', ny)
            if 'xh' not in ds.dimensions:
                ds.createDimension('xh', nx)
            if var_name_out not in ds.variables:
                var = ds.createVariable(var_name_out, 'f4', (time_name_out, 'yh', 'xh'), fill_value=1.e+20)
                var[:] = self.remapped
    
#######################
### 3D Scalar Class ###
#######################

class _Remapper3DScalar(_RemapperBase):
    """ Class for 3D scalar datatype (temperature, salinity) """
    def __init__(self, args, ndepths):
        self.data = args[0]
        self.ndepths = ndepths
        self.remapped = None

    def remap_from_file(self, wgt_file):
        """ Remap onto the destination center points based on ESMF_RegridWeightGen weight file. """
        S_mat, dst_dims, nb = Remapper.unpack_weights(wgt_file)

        dims = (1,self.ndepths,int(dst_dims[1]), int(dst_dims[0])) # Dims are flipped

        data_interp = np.zeros((1,self.ndepths,nb))
        N = 1.2676506e+30 # NaN placeholder value

        t = 0
        for d in range(self.ndepths):
            data_src = np.array(self.data[t,d,:,:])
            data_level = np.where(data_src.ravel()==N, 0, data_src.ravel())
            data_interp[t,d,:] = S_mat.dot(data_level)
   
        data_interp = data_interp.reshape(dims)

        self.remapped = data_interp

    def write_to_file(self, out_file, dz_name_out, time_name_out, *var_name_out):
        var_name_out = var_name_out[0] # Should only have one input for Scalar Classes
        if self.remapped is None:
            raise ValueError(f"No remapped data to write out.")

        __, __, ny, nx = np.shape(self.remapped)

        with Dataset(out_file, 'a', format='NETCDF4') as ds:
            if 'yh' not in ds.dimensions:
                ds.createDimension('yh', ny)
            if 'xh' not in ds.dimensions:
                ds.createDimension('xh', nx)
            if var_name_out not in ds.variables:
                var = ds.createVariable(var_name_out, 'f4', (time_name_out, dz_name_out, 'yh', 'xh'), fill_value=1.e+20)
                var[:] = self.remapped

#######################
### 3D Vector Class ###
#######################

class _Remapper3DVector(_RemapperBase):
    """ Class for 3D Vector datatype (velocity) """
    def __init__(self, args, ndepths, convert_angle):
        self.data = (args[0], args[1])

        if len(args) == 3:
            self.angle = args[2]
        else:
            self.angle = None

        self.ndepths = ndepths
        self.convert_angle = convert_angle

        self.remapped = None
        self.staggered = None

    def remap_from_file(self, *wgt_file):
        """ Determines whether to remap to centers or directly to edges based on whether
            provided 1 (center) weight file or 2 (u,v) weight files. """
        if len(wgt_file) == 1:
            self.staggered = False
            self.remap_to_center(*wgt_file)
        elif len(wgt_file) == 2:
            self.staggered = True
            self.remap_to_edges(*wgt_file)

    def remap_to_edges(self, *wgt_file):
        """ Remap (u,v) to edges, rotate vector, then extract v from v-edges and u from u-edges"""
        self.remapped = []
        N = 1.2676506e+30 # NaN placeholder value
        subgrids = ['u','v']

        for i in range(2): # For each edge subgrid
            sg = subgrids[i]
            if (self.angle is not None) and (self.convert_angle): # Get angles for subgrids from supergrid
                angle = self.convert_angle_to_subgrid(self.angle[:], sg)

            wgts = wgt_file[i]
            S_mat, dst_dims, nb = Remapper.unpack_weights(wgts)

            dims = (1,self.ndepths,int(dst_dims[1]), int(dst_dims[0])) # Dims are flipped

            data_u = np.zeros((1,self.ndepths,nb))
            data_v = np.zeros((1,self.ndepths,nb))
            
            t = 0

            for d in range(self.ndepths):
                # Interpolate u
                data_src = np.array(self.data[0][t,d,:,:])
                data_level = np.where(data_src.ravel()==N, 0, data_src.ravel())
                data_u[t,d,:] = S_mat.dot(data_level)

                # Interpolate v
                data_src = np.array(self.data[1][t,d,:,:])
                data_level = np.where(data_src.ravel()==N, 0, data_src.ravel())
                data_v[t,d,:] = S_mat.dot(data_level)

            data_u = data_u.reshape(dims)
            data_v = data_v.reshape(dims)

            if self.angle is not None: # No center angle assumes destination grid is North-East aligned
                data_u, data_v = self.rotate_vector(data_u, data_v, angle)
           
            # Only keep rotated u on u grid and rotated v on v grid
            if sg == 'u':
                self.remapped.append(data_u)
            else: # 'v'
                self.remapped.append(data_v)

    def remap_to_center(self, wgt_file):
        """ Remap to every point, and then rotate vector. Does not use subgrids. """
        self.remapped = []
        N = 1.2676506e+30 # NaN placeholder value
        
        S_mat, dst_dims, nb = Remapper.unpack_weights(wgt_file)
        
        dims = (1,self.ndepths,int(dst_dims[1]), int(dst_dims[0])) # Dims are flipped
        
        data_u = np.zeros((1,self.ndepths,nb))
        data_v = np.zeros((1,self.ndepths,nb))
        
        t = 0
        
#        for d in range(self.ndepths):
#            print("\n\n ================ \n\n")
#            # Interpolate u
#            data_src = np.array(self.data[0][t,d,:,:])
#            data_level = np.where(data_src.ravel()==N, 0, data_src.ravel())
#            print(f"Data Level -- min: {np.min(data_level)}; max: {np.max(data_level)}")
#            # Dynamically reshape result to match data_u[t, d, :] -- solves mysterious reshaping error
#            result = S_mat.dot(data_level)
#            print(f"Result-- min: {np.min(result)}; max: {np.max(result)}")
#            target_shape = data_u[t, d, :].shape
#            data_u[t, d, :] = result.reshape(target_shape)
#            print(f"Data U -- min: {np.min(data_u)}; max: {np.max(data_u)}")
#        
#            # Interpolate v
#            data_src = np.array(self.data[1][t,d,:,:])
#            data_level = np.where(data_src.ravel()==N, 0, data_src.ravel())
#            print(f"Data Level -- min: {np.min(data_level)}; max: {np.max(data_level)}")
#            # Dynamically reshape result to match data_v[t, d, :] -- solves mysterious reshaping error
#            result = S_mat.dot(data_level)
#            print(f"Result-- min: {np.min(result)}; max: {np.max(result)}")
#            target_shape = data_v[t, d, :].shape
#            data_v[t, d, :] = result.reshape(target_shape)
#            print(f"Data V -- min: {np.min(data_v)}; max: {np.max(data_v)}")
#            print("\n\n ================ \n\n")

        for d in range(self.ndepths):
            # Interpolate u
            data_src = np.array(self.data[0][t,d,:,:])
            data_level = np.where(data_src.ravel()==N, 0, data_src.ravel())
            data_u[t,d,:] = S_mat.dot(data_level)

            # Interpolate v
            data_src = np.array(self.data[1][t,d,:,:])
            data_level = np.where(data_src.ravel()==N, 0, data_src.ravel())
            data_v[t,d,:] = S_mat.dot(data_level)

        data_u = data_u.reshape(dims)
        data_v = data_v.reshape(dims)

        if self.angle is not None: # No center angle assumes destination grid is North-East aligned
            data_u, data_v = self.rotate_vector(data_u, data_v, self.angle)
        
        self.remapped.append(data_u)
        self.remapped.append(data_v)

    @staticmethod
    def rotate_vector(u, v, a):
        """ Rotates vector from North-East alignment to grid alignment specified by the angle, a """
        rotated_u = u*np.cos(a) + v*np.sin(a) 
        rotated_v = v*np.cos(a) + u*np.sin(a)

        return rotated_u, rotated_v

    @staticmethod
    def convert_angle_to_subgrid(var, gridtype):
        """Converts from supergrid to specified subgrid points"""
        if gridtype == "center": # Extract center points of grid
            cvar = var[1::2, 1::2]
        elif gridtype == "u": # Extract the East/West edges of grid
            cvar = var[1::2,0::2]
        elif gridtype == "v": # Extract the North/South edges of grid
            cvar = var[0::2,1::2]
        else:
            raise ValueError("Grid type not supported. Must be center, u, or v")
    
        return cvar

    def write_to_file(self, out_file, dz_name_out, time_name_out, *var_name_out):
        if self.remapped is None:
            raise ValueError(f"No remapped data to write out.")

        u_name = var_name_out[0]
        v_name = var_name_out[1]

        __, __, ny, nx = np.shape(self.remapped[0])

        if self.staggered: # U and V are located on different subgrids
            # Write u out
            with Dataset(out_file, 'a', format='NETCDF4') as ds:
                if 'yh' not in ds.dimensions:
                    ds.createDimension('yh', ny)
                if 'xq' not in ds.dimensions:
                    ds.createDimension('xq', nx)
                if u_name not in ds.variables:
                    var = ds.createVariable(u_name, 'f4', (time_name_out, dz_name_out, 'yh', 'xq'), fill_value=1.e+20)
                    var[:] = self.remapped[0]

            # Write v out
            __, __, ny, nx = np.shape(self.remapped[1])

            with Dataset(out_file, 'a', format='NETCDF4') as ds:
                if 'yq' not in ds.dimensions:
                    ds.createDimension('yq', ny)
                if 'xh' not in ds.dimensions:
                    ds.createDimension('xh', nx)
                if v_name not in ds.variables:
                    var = ds.createVariable(v_name, 'f4', (time_name_out, dz_name_out, 'yq', 'xh'), fill_value=1.e+20)
                    var[:] = self.remapped[1]
        else: # U and V are colocated
            with Dataset(out_file, 'a', format='NETCDF4') as ds:
                if 'yh' not in ds.dimensions:
                    ds.createDimension('yh', ny)
                if 'xh' not in ds.dimensions:
                    ds.createDimension('xh', nx)
                if u_name not in ds.variables:
                    var = ds.createVariable(u_name, 'f4', (time_name_out, dz_name_out, 'yh', 'xh'), fill_value=1.e+20)
                    var[:] = self.remapped[0]
                if v_name not in ds.variables:
                    var = ds.createVariable(v_name, 'f4', (time_name_out, dz_name_out, 'yh', 'xh'), fill_value=1.e+20)
                    var[:] = self.remapped[1]
