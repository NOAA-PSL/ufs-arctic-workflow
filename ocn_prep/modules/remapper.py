from abc import ABC, abstractmethod
import numpy as np
import netCDF4 as nc
from netCDF4 import Dataset
from scipy.sparse import coo_matrix

###########################
### Base Remapper Class ###
###########################

class Remapper:
    def __new__(cls, *args, depth_name = None, src_angle = None, dst_angle = None, src_ang_hgrid = False, dst_ang_hgrid = False):
        """ Determine data type based on number of input dimensions and instantiate accordingly """
        if (len(args)<1 or len(args)>3):
            raise ValueError("Must provide either 1 (scalar) or 2 (vectore) netCDF4 variables")

        if not all(isinstance(var, nc.Variable) for var in args):
            raise ValueError("All positional arguments must be netCDF4 variables")

        dataset = args[0].group()

        def check_depth_dimension(dataset):
            if depth_name is not None:
                if depth_name not in args[0].dimensions:
                    return 1
                else:
                    idx = args[0].dimensions.index(depth_name)
                    return args[0].shape[idx]

#            depth_dims = {'depth', 'depths', 'z'}
#            for dim_name, dim in dataset.dimensions.items():
#                if dim_name.lower() in depth_dims:
#                    return len(dim)

            return 0

        ndepths = check_depth_dimension(dataset)
        if len(args) == 1:
            if ndepths>1:
                instance = _Remapper3DScalar(args, ndepths)
            else:
                instance = _Remapper2DScalar(args)
        else:
            if ndepths>1:
                instance = _Remapper3DVector(args, ndepths, src_angle, dst_angle, src_ang_hgrid, dst_ang_hgrid)
            else:
                raise ValueError("Vector interpolation only implemented for 3D data")

        return instance

    @staticmethod
    def unpack_weights(wgt_file):
        """ Unpacks weight file generated by ESMF_RegridWeightGen """
        wgt_grid = Dataset(wgt_file, 'r')
        na = len(wgt_grid.dimensions['n_a'])
        nb = len(wgt_grid.dimensions['n_b'])
        col = np.array(wgt_grid.variables['col'][:])-1 # Convert to 0-base order
        row = np.array(wgt_grid.variables['row'][:])-1
        S = np.array(wgt_grid.variables['S'][:])
        S_mat = coo_matrix((S, (row, col)), shape=(nb, na))

        dst_dims = wgt_grid.variables['dst_grid_dims']
    
        return S_mat, dst_dims, nb


class _RemapperBase(ABC):
    @abstractmethod
    def remap_from_file(self, wgt_file) -> np.ndarray:
        pass

    @abstractmethod
    def write_to_file(self, out_file, var_name_out) -> None:
        pass

#######################
### 2D Scalar Class ###
#######################

class _Remapper2DScalar(_RemapperBase):
    """ Class for 2D scalar dataype (ssh) """
    def __init__(self, args):
        self.data = args[0]
        self.remapped = None

    def remap_from_file(self, wgt_file):
        S_mat, dst_dims, __ = Remapper.unpack_weights(wgt_file)

        dims = (1, dst_dims[1], dst_dims[0]) # Dims are flipped

        N = 1.2676506e+30 # NaN placeholder value

        t = 0
        data_src = np.array(self.data[t,:,:])
        data_level = np.where(data_src.ravel()==N, 0, data_src.ravel())
        data_interp = S_mat.dot(data_level)

        data_interp = data_interp.reshape(dims)

        self.remapped = data_interp

    def write_to_file(self, out_file, dz_name_out, time_name_out, forecast_iter, *var_name_out):
        var_name_out = var_name_out[0] # Should only have one input for Scalar Classes
        if self.remapped is None:
            raise ValueError(f"No remapped data to write out.")

        __, ny, nx = np.shape(self.remapped)

        with Dataset(out_file, 'a', format='NETCDF4') as ds:
            if (forecast_iter == 0): # First timestep
                if 'yh' not in ds.dimensions:
                    ds.createDimension('yh', ny)
                if 'xh' not in ds.dimensions:
                    ds.createDimension('xh', nx)
                if var_name_out not in ds.variables:
                    var = ds.createVariable(var_name_out, 'f4', (time_name_out, 'yh', 'xh'), fill_value=1.e+20)
                    var[:] = self.remapped
            else: # Append subsequent timesteps
                var = ds.variables[var_name_out]
                var[forecast_iter,:,:] = self.remapped[0,:,:]
                
    
#######################
### 3D Scalar Class ###
#######################

class _Remapper3DScalar(_RemapperBase):
    """ Class for 3D scalar datatype (temperature, salinity) """
    def __init__(self, args, ndepths):
        self.data = args[0]
        self.ndepths = ndepths
        self.remapped = None

    def remap_from_file(self, wgt_file):
        """ Remap onto the destination center points based on ESMF_RegridWeightGen weight file. """
        S_mat, dst_dims, nb = Remapper.unpack_weights(wgt_file)

        dims = (1,self.ndepths,int(dst_dims[1]), int(dst_dims[0])) # Dims are flipped

        data_interp = np.zeros((1,self.ndepths,nb))
        N = 1.2676506e+30 # NaN placeholder value

        t = 0
        for d in range(self.ndepths):
            data_src = np.array(self.data[t,d,:,:])
            data_level = np.where(data_src.ravel()==N, 0, data_src.ravel())
            data_interp[t,d,:] = S_mat.dot(data_level)
   
        data_interp = data_interp.reshape(dims)

        self.remapped = data_interp

    def write_to_file(self, out_file, dz_name_out, time_name_out, forecast_iter, *var_name_out):
        var_name_out = var_name_out[0] # Should only have one input for Scalar Classes
        if self.remapped is None:
            raise ValueError(f"No remapped data to write out.")

        __, __, ny, nx = np.shape(self.remapped)

        with Dataset(out_file, 'a', format='NETCDF4') as ds:
            print(f"Forecast iter is {forecast_iter}")
            if (forecast_iter == 0): # First timestep
                if 'yh' not in ds.dimensions:
                    ds.createDimension('yh', ny)
                if 'xh' not in ds.dimensions:
                    ds.createDimension('xh', nx)
                if var_name_out not in ds.variables:
                    var = ds.createVariable(var_name_out, 'f4', (time_name_out, dz_name_out, 'yh', 'xh'), fill_value=1.e+20)
                    var[:] = self.remapped
            else: # Append subsequent timesteps
                var = ds.variables[var_name_out]
                var[forecast_iter,:,:,:] = self.remapped[0,:,:,:]

#######################
### 3D Vector Class ###
#######################

class _Remapper3DVector(_RemapperBase):
    """ Class for 3D Vector datatype (velocity) """
    def __init__(self, args, ndepths, src_angle, dst_angle, src_ang_hgrid, dst_ang_hgrid):
        self.data = (args[0], args[1])
        self.ndepths = ndepths
        self.src_angle = src_angle
        self.dst_angle = dst_angle
        self.src_hgrid = src_ang_hgrid
        self.dst_hgrid = dst_ang_hgrid
        self.remapped = None
        self.staggered = None

        if (self.src_angle is not None) and (self.src_hgrid):
            self.src_angle = self.convert_angle_to_subgrid(self.src_angle[:], 'center')

    def remap_from_file(self, *wgt_file):
        """ Determines whether to remap to centers or directly to edges based on whether
            provided 1 (center) weight file or 2 (u,v) weight files. """
        if len(wgt_file) == 1:
            self.staggered = False
            self.remap_to_center(*wgt_file)
        elif len(wgt_file) == 2:
            self.staggered = True
            self.remap_to_edges(*wgt_file)

    def remap_to_edges(self, *wgt_file):
        """ Remap (u,v) to edges, rotate vector, then extract v from v-edges and u from u-edges"""
        self.remapped = []
        N = 1.2676506e+30 # NaN placeholder value
        subgrids = ['u','v']

        for i in range(2): # For each edge subgrid
            sg = subgrids[i]
            if (self.dst_angle is not None) and (self.dst_hgrid): # Get angles for subgrids from supergrid
                dst_angle_sg = self.convert_angle_to_subgrid(self.dst_angle[:], sg)
            else: 
                dst_angle_sg = None

            wgts = wgt_file[i]
            S_mat, dst_dims, nb = Remapper.unpack_weights(wgts)

            dims = (1,self.ndepths,int(dst_dims[1]), int(dst_dims[0])) # Dims are flipped

            data_u = np.zeros((1,self.ndepths,nb))
            data_v = np.zeros((1,self.ndepths,nb))
            
            t = 0

            for d in range(self.ndepths):
                data_src_u = np.array(self.data[0][t,d,:,:])
                data_src_v = np.array(self.data[1][t,d,:,:])

                # Rotate to N-E direction from source grid
                if self.src_angle is not None:
                    data_src_u, data_src_v = self.rotate_vector(data_src_u, data_src_v, self.src_angle, grid='dst')

                # Interpolate u
                data_level = np.where(data_src_u.ravel()==N, 0, data_src_u.ravel())
                data_u[t,d,:] = S_mat.dot(data_level)

                # Interpolate v
                data_level = np.where(data_src_v.ravel()==N, 0, data_src_v.ravel())
                data_v[t,d,:] = S_mat.dot(data_level)

            data_u = data_u.reshape(dims)
            data_v = data_v.reshape(dims)

            if dst_angle_sg is not None: # No center angle assumes destination grid is North-East aligned
                data_u, data_v = self.rotate_vector(data_u, data_v, dst_angle_sg, grid='dst')
           
            # Only keep rotated u on u grid and rotated v on v grid
            if sg == 'u':
                self.remapped.append(data_u)
            else: # 'v'
                self.remapped.append(data_v)

    def remap_to_center(self, wgt_file):
        """ Remap to every point, and then rotate vector. Does not use subgrids. """
        self.remapped = []
        N = 1.2676506e+30 # NaN placeholder value
        
        S_mat, dst_dims, nb = Remapper.unpack_weights(wgt_file)
        
        dims = (1,self.ndepths,int(dst_dims[1]), int(dst_dims[0])) # Dims are flipped
        
        data_u = np.zeros((1,self.ndepths,nb))
        data_v = np.zeros((1,self.ndepths,nb))
        
        t = 0

        for d in range(self.ndepths):
            data_src_u = np.array(self.data[0][t,d,:,:])
            data_src_v = np.array(self.data[1][t,d,:,:])

            # Rotate to N-E direction from source grid
            if self.src_angle is not None:
                data_src_u, data_src_v = self.rotate_vector(data_src_u, data_src_v, self.src_angle, grid='src')
            
            # Interpolate u
            data_level = np.where(data_src_u.ravel()==N, 0, data_src_u.ravel())
            data_u[t,d,:] = S_mat.dot(data_level)

            # Interpolate v
            data_level = np.where(data_src_v.ravel()==N, 0, data_src_v.ravel())
            data_v[t,d,:] = S_mat.dot(data_level)

        data_u = data_u.reshape(dims)
        data_v = data_v.reshape(dims)

        if self.dst_angle is not None: # No center angle assumes destination grid is North-East aligned
            data_u, data_v = self.rotate_vector(data_u, data_v, self.dst_angle, grid='dst')
        
        self.remapped.append(data_u)
        self.remapped.append(data_v)

    @staticmethod
    def rotate_vector(u, v, a, grid):
        """ Rotates vector from North-East alignment to grid alignment specified by the angle, a """
        if (np.min(a) < -1*np.pi) or (np.max(a) > np.pi):
            a = np.radians(a)

        cosa = np.cos(a)
        sina = np.sin(a)

        if grid=='dst':
            rotated_u = u*cosa + v*sina
            rotated_v = v*cosa - u*sina
        elif grid=='src':
            rotated_u = u*cosa - v*sina
            rotated_v = v*cosa + u*sina

        return rotated_u, rotated_v

    @staticmethod
    def convert_angle_to_subgrid(var, gridtype):
        """Converts from supergrid to specified subgrid points"""
        if gridtype == "center": # Extract center points of grid
            cvar = var[1::2, 1::2]
        elif gridtype == "u": # Extract the East/West edges of grid
            cvar = var[1::2,0::2]
        elif gridtype == "v": # Extract the North/South edges of grid
            cvar = var[0::2,1::2]
        else:
            raise ValueError("Grid type not supported. Must be center, u, or v")
    
        return cvar

    def write_to_file(self, out_file, dz_name_out, time_name_out, forecast_iter, *var_name_out):
        if self.remapped is None:
            raise ValueError(f"No remapped data to write out.")

        u_name = var_name_out[0]
        v_name = var_name_out[1]

        __, __, ny, nx = np.shape(self.remapped[0])

        if self.staggered: # U and V are located on different subgrids
            # Write u out
            with Dataset(out_file, 'a', format='NETCDF4') as ds:
                if (forecast_iter==0):
                    if 'yh' not in ds.dimensions:
                        ds.createDimension('yh', ny)
                    if 'xq' not in ds.dimensions:
                        ds.createDimension('xq', nx)
                    if u_name not in ds.variables:
                        var = ds.createVariable(u_name, 'f4', (time_name_out, dz_name_out, 'yh', 'xq'), fill_value=1.e+20)
                        var[:] = self.remapped[0]
                else:
                    var = ds.variables[u_name]
                    var[forecast_iter,:,:,:] = self.remapped[0][0,:,:,:]

            # Write v out
            __, __, ny, nx = np.shape(self.remapped[1])

            with Dataset(out_file, 'a', format='NETCDF4') as ds:
                if (forecast_iter == 0):
                    if 'yq' not in ds.dimensions:
                        ds.createDimension('yq', ny)
                    if 'xh' not in ds.dimensions:
                        ds.createDimension('xh', nx)
                    if v_name not in ds.variables:
                        var = ds.createVariable(v_name, 'f4', (time_name_out, dz_name_out, 'yq', 'xh'), fill_value=1.e+20)
                        var[:] = self.remapped[1]
                else:
                    var = ds.variables[v_name]
                    var[forecast_iter,:,:,:] = self.remapped[1][0,:,:,:]

        else: # U and V are colocated
            with Dataset(out_file, 'a', format='NETCDF4') as ds:
                if (forecast_iter == 0):
                    if 'yh' not in ds.dimensions:
                        ds.createDimension('yh', ny)
                    if 'xh' not in ds.dimensions:
                        ds.createDimension('xh', nx)
                    if u_name not in ds.variables:
                        var = ds.createVariable(u_name, 'f4', (time_name_out, dz_name_out, 'yh', 'xh'), fill_value=1.e+20)
                        var[:] = self.remapped[0]
                    if v_name not in ds.variables:
                        var = ds.createVariable(v_name, 'f4', (time_name_out, dz_name_out, 'yh', 'xh'), fill_value=1.e+20)
                        var[:] = self.remapped[1]
                else:
                    uvar = ds.variables[u_name]
                    uvar[forecast_iter,:,:,:] = self.remapped[0][0,:,:,:]
                    vvar = ds.variables[v_name]
                    vvar[forecast_iter,:,:,:] = self.remapped[1][0,:,:,:]
